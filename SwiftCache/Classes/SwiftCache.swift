//
//  SwiftCache
//  Pods
//
//  Created by Tomas Radvansky on 21/11/2016.
//
//

import Foundation
import Alamofire
import RealmSwift
import FCUUID

/**
 SwiftCache singleton class
 */
@objc public class SwiftCache: NSObject {
    //Development constant
    public var shouldDebug = true
    //Array to store pre-existing DownloadRequest
    //mapped to UUID generated by FCUUID library
    var pendingRequests:[String:DownloadRequest] = [:]
    //Default cache size
    var maxCacheSize:Int64 = 10 * 1024 * 1024
    
    let realm = try! Realm(configuration: Realm.Configuration(inMemoryIdentifier: "MyInMemoryRealm"))
    
    //MARK:- Singleton instance
    @objc public class var sharedInstance :SwiftCache {
        struct Singleton {
            static let instance = SwiftCache()
        }
        return Singleton.instance
    }
    
    /**
     To override default cache size
     - parameters:
     - size: Cache size in Bytes
     - Throws: NSError in case of invalid memory size
     */
    public func setCacheSize(size:Int64) throws
    {
        //Check if there is any pending downloads
        if self.pendingRequests.count > 0
        {
            let userInfo: [NSObject : AnyObject] =
                [
                    NSLocalizedDescriptionKey as NSObject :  "Number of pre-existing downloadRequests has to be zero!" as AnyObject
            ]
            let err = NSError(domain: "SwiftCache", code: 502, userInfo: userInfo)
            throw err
            return
        }
        
        //Use current value (as a fallback)
        var freeSpaceSize:Int64 = self.maxCacheSize
        do
        {
            //Obtain free space:
            let dictionary =  try FileManager.default.attributesOfFileSystem(forPath: NSHomeDirectory())
            freeSpaceSize = ((dictionary[FileAttributeKey.systemFreeSize] as AnyObject).longLongValue)
        }
        catch let error as NSError
        {
            if shouldDebug
            {
                print(error.localizedDescription)
            }
        }
        
        //If size is positive and less then free space assign it
        if size > 0 && size < freeSpaceSize
        {
            self.maxCacheSize = size
        }
        else
        {
            let userInfo: [NSObject : AnyObject] =
                [
                    NSLocalizedDescriptionKey as NSObject :  "Invalid memory size, free space: \(freeSpaceSize)" as AnyObject
            ]
            let err = NSError(domain: "SwiftCache", code: 501, userInfo: userInfo)
            throw err
        }
    }
    
    /**
     Main function of SwiftCache used for loading resources
     - parameters:
     - url: Remote location
     - completionHandler: closure to get CachedObject or NSError
     - Returns: DownloadRequest Task Identifier
     */
    public func loadResource(url:URL, completionHandler:((_ result:CachedObject?, _ error:NSError?) -> Void)!)->String
    {
        //Generate unique id for upcoming task
        let taskID:String = FCUUID.uuid()
        
        //Return cached object if there is any
        if let data = isResourceCached(url: url)
        {
            //Try to update timestamp to optimize cache
            do
            {
                try self.realm.write {
                    data.timestamp = NSDate()
                }
            }
            catch let error as NSError
            {
                print(error)
            }
            completionHandler(data, nil)
        }
        else
        {
            //Download file to temp directory
            let destination: DownloadRequest.DownloadFileDestination = { url, response in
                var documentsURL:URL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
                
                documentsURL.appendPathComponent(url.lastPathComponent)
                return (documentsURL, [.removePreviousFile, .createIntermediateDirectories])
            }
            
            //Run donwload task and monitor its progress
            let request = Alamofire.download(url,to:destination).downloadProgress(closure: { (progress:Progress) in
                //Check if image was not cached in the meantime
                if (self.isResourceCached(url: url) != nil)
                {
                    self.cancelDownloadTask(taskID: taskID)
                }
            }).response(completionHandler: { (response:DefaultDownloadResponse) in
                //Delete temp file
                if let url:URL = response.destinationURL
                {
                    do
                    {
                        try FileManager.default.removeItem(at: url)
                    }
                    catch let error as NSError
                    {
                        if self.shouldDebug
                        {
                            print(error)
                        }
                    }
                }
            }).responseData { (dataResponse) in
                //Get data response and check for errors
                if let responseError = dataResponse.result.error
                {
                    completionHandler(nil, responseError as NSError?)
                }
                else
                {
                    //Create new CachedObject entry, crucial for RealmDB
                    let objectToCache = CachedObject()
                    
                    //Unwrap and assing values
                    if let unwrappedMIMEType:String = dataResponse.response?.allHeaderFields["Content-Type"] as? String
                    {
                        objectToCache.MIMEType = unwrappedMIMEType
                    }
                    if let unwrappedURLString:String = dataResponse.response?.url?.absoluteString
                    {
                        objectToCache.url = unwrappedURLString
                    }
                    
                    if let unwrappedData:Data = dataResponse.result.value
                    {
                        objectToCache.data = unwrappedData as! NSData
                    }
                    
                    //Try to cache object
                    do
                    {
                        try self.cacheObject(object: objectToCache)
                        completionHandler(objectToCache, nil)
                    }
                    catch let error as NSError
                    {
                        //If there is cached object return it with error
                        //Let user decide
                        completionHandler(self.isResourceCached(url: url), error)
                    }
                }
                //Finally remove task from pending tasks
                self.pendingRequests.removeValue(forKey: taskID)
            }
            //Add task to pending tasks to allow its cancellation
            self.pendingRequests[taskID] = request
        }
        return taskID
    }
    
    /**
     To cancel pre-existing download task
     - parameters:
     - taskID: Returned from loadResource method
     */
    public func cancelDownloadTask(taskID:String)
    {
        self.pendingRequests[taskID]?.cancel()
    }
    
    /**
     To cancel all pre-existing download tasks
     */
    public func cancelAllDownloadTasks()
    {
        for task in self.pendingRequests.values
        {
            task.cancel()
        }
    }
    
    /**
     Internal method to check if remote resource is cached
     - parameters:
     - url: Remote location
     - Returns: Optional CachedObject, resource is not cached in case of nil
     */
    func isResourceCached(url:URL)->CachedObject?
    {
        let cachedObjects = realm.objects(CachedObject.self).filter("url = %@", url.absoluteString)
        if let object:CachedObject = cachedObjects.first
        {
            //Make sure that object is usable (Deletion?)
            if !object.isInvalidated
            {
                return object
            }
        }
        return nil
    }
    
    /**
     Helper method to retrieve all cached objects
     - Returns: Array of all CachedObjects
     */
    public func getAllCachedObjects()->Array<CachedObject>
    {
        //Dump DB
        var result:Array<CachedObject> = Array<CachedObject>()
        let cachedObjects = realm.objects(CachedObject.self)
        for object in cachedObjects
        {
            result.append(object)
        }
        return result
    }
    
    /**
     Delete cached remote resource
     - parameters:
     - url: Remote location
     - Throws: RealmDB errors
     */
    public func deleteCachedObject(url:String) throws
    {
        let cachedObjects = realm.objects(CachedObject.self).filter("url = %@", url)
        if let object:CachedObject = cachedObjects.first
        {
            try realm.write {
                realm.delete(object)
            }
        }
    }
    
    /**
     Clear cache whole cache or for MIMEType
     - parameters:
     - MIMEType: Optional Remote location, nil remove everything
     - Throws: RealmDB errors
     */
    public func clearCache(MIMEType:String?) throws
    {
        let cachedObjects = realm.objects(CachedObject.self)
        if MIMEType != nil
        {
            cachedObjects.filter("MIMEType = %@", MIMEType)
        }
        try realm.write {
            for object in cachedObjects
            {
                if shouldDebug
                {
                    print("Delete object - \(object.url)")
                }
                realm.delete(object)
            }
        }
    }
    
    /**
     Internal method to retrieve current cache size
     - parameters:
     - MIMEType: Optional MIME type, nil to get total size
     - completionHandler: closure to get CachedObject or NSError
     - Returns: Size in bytes
     */
    func getCacheSize(MIMEType:String?) -> Int64
    {
        var cacheSize:Int64 = 0
        let cachedObjects = realm.objects(CachedObject.self)
        if MIMEType != nil
        {
            cachedObjects.filter("MIMEType = %@", MIMEType)
        }
        for object in cachedObjects
        {
            cacheSize = cacheSize + object.data.length
        }
        return cacheSize
    }
    
    /**
     Internal method to cache object
     - parameters:
     - objecet: Object to cache
     - Throws: RealmDB errors
     */
    func cacheObject(object:CachedObject) throws
    {
        //Cache object in RealmDB
        try realm.write {
            //Make sure that I have enough space for MIMEType
            while getCacheSize(MIMEType:object.MIMEType) + object.data.length > maxCacheSize
            {
                //If not remove last object based on timestamp
                if let cachedObject = realm.objects(CachedObject.self).sorted(byProperty: "timestamp").last
                {
                    if shouldDebug
                    {
                        print("Delete - \(cachedObject.url) for MIME: \(object.MIMEType)")
                    }
                    realm.delete(cachedObject)
                }
            }
            //Finally after cache is clean, add object
            realm.add(object, update: true)
            
        }
        if shouldDebug
        {
            print("Cache Size:\(getCacheSize(MIMEType: object.MIMEType)) for MIME: \(object.MIMEType)")
        }
    }
}
